---
title: Git tips and uses
author: Lorenzo Drumond
date: 2024-07-24T15:27:48
last: 2024-07-24T21:21:53
zk_id: c6f7ffcad38b9851fc6c499039fde11f
tags: #github #primeagen #programming #computer_science #git
---


# Git tips and uses

Git is the distributed version control system (VCS). Nearly every developer in the world uses it to manage their code. It has quite a monopoly on VCS. Developers use Git to:

- Keep a history of their code changes
- Revert mistakes made in their code
- Collaborate with other developers
- Make backups of their code
- And much more

## Basics

The major difference between Git and any other VCS (Subversion and friends included) is the way
Git thinks about its data. Conceptually, most other systems store information as a list of file-based
changes.

Git doesn’t think of or store its data this way. Instead, Git thinks of its data more like a series of
snapshots of a miniature filesystem. With Git, every time you commit, or save the state of your
project, Git basically takes a picture of what all your files look like at that moment and stores a
reference to that snapshot. To be efficient, if files have not changed, Git doesn’t store the file again,
just a link to the previous identical file it has already stored. Git thinks about its data more like a
stream of snapshots.

Everything in Git is checksummed before it is stored and is then referred to by that checksum. This
means it’s impossible to change the contents of any file or directory without Git knowing about it.
This functionality is built into Git at the lowest levels and is integral to its philosophy. You can’t lose
information in transit or get file corruption without Git being able to detect it.

Git stores everything in its database not by file name but by the hash value of its contents.

### The Three States

Git has three main states that your files can reside in: modified, staged, and committed:

- Modified means that you have changed the file but have not committed it to your database yet.
- Staged means that you have marked a modified file in its current version to
  go into your next commit snapshot.
- Committed means that the data is safely stored in your local database.

This leads us to the three main sections of a Git project: the working tree, the staging area, and the
Git directory.

The _working tree_ is a single checkout of one version of the project. These files are pulled out of the
compressed database in the Git directory and placed on disk for you to use or modify.

The _staging area_ is a file, generally contained in your Git directory, that stores information about
what will go into your next commit. Its technical name in Git parlance is the “index”, but the phrase
“staging area” works just as well.

The _Git directory_ is where Git stores the metadata and object database for your project. This is the
most important part of Git, and it is what is copied when you clone a repository from another
computer.

### Worflow

The basic Git workflow goes something like this:

1. You modify files in your working tree.
2. You selectively stage just those changes you want to be part of your next
   commit, which adds only those changes to the staging area.
3. You do a commit, which takes the files as they are in the staging area and
   stores that snapshot permanently to your Git directory.

If a particular version of a file is in the Git directory, it’s considered committed. If it has been
modified and was added to the staging area, it is staged. And if it was changed since it was checked
out but has not been staged, it is modified.

## Porcelain and Plumbing

In Git, commands are divided into high-level ("porcelain") commands and low-level ("plumbing") commands.

## Repo

The very first step of any project is to create a repository. A Git "repository" (or "repo") represents a single project.

A repo is essentially just a directory that contains a project (other directories and files). The only difference is that it also contains a hidden .git directory. That hidden directory is where Git stores all of its internal tracking and versioning information for the project.

To initialize a git repo, use

```bash
git init
```

## Status

A file can be in one of several states in a Git repository. Here are a few important ones:

- untracked: Not being tracked by Git
- staged: Marked for inclusion in the next commit
- committed: Saved to the repository's history

The `git status` command shows you the current state of your repo. It will tell you which files are untracked, staged, and committed.

## Adding to stage

`git add <file|pattern>` will add your files to the _index_ or staging area. They will be tracked as staged

## Committing

Once the files you want to save have been added to the index, you can commit them to the git directory with

`git commit -m "message"`

To modify the message of the latest commit, do `git commit --amend -m "new message"`

## Commit history and Logs

A Git repo is a (potentially very long) list of commits, where each commit represents the full state of the repository at a given point in time.

The git log command shows a history of the commits in a repository. This is what makes Git a version control system. You can see:

- Who made a commit
- When the commit was made
- What was changed

Each commit has a unique identifier called a "commit hash". This is a long string of characters that uniquely identifies the commit: 5ba786fcc93e8092831c01e71444b9baa2228a4f

For convenience, you can refer to any commit or change within Git by using the first 7 characters of its hash: 5ba786f.

While commit hashes are derived from their content changes, there's also some other stuff that affects the end hash. For example:

- The commit message
- The author's name and email
- The date and time
- Parent (previous) commit hashes

Each commit points to its previous commit, so that is's always possible to reconstruct the whole commit history of a single commit.

## Plumbing

All the data in a Git repository is stored directly in the (hidden) .git directory. That includes all the commits, branches, tags, and other objects we'll learn about later.

Git is made up of objects that are stored in the .git/objects directory. A commit is just a type of object.

e.g.:

```bash
objects
├── 5b
│   └── 21d4f16a4b07a6cde5a3242187f6a5a68b060f
├── c7
│   └── b52ce6f71c145b4d2ae52dac5bea86adae0090
├── ef
│   └── 7e93fc61a91deecaa551c4707e4c3049af42c9
├── info
└── pack
```

Each commit object is compressed as a stream of bytes.

Git has a built-in plumbing command, `cat-file`, that allows us to see the contents of a commit without needing to futz around with the object files directly.

```bash
git cat-file -p c7b52ce6f71c145b4d2ae52dac5bea86adae0090
```

A _tree_ is git's way of storing a directory
A _blob_ is git's way of storing a file

```bash
$ git cat-file -p c7b52ce6f71c145b4d2ae52dac5bea86adae0090
tree 5b21d4f16a4b07a6cde5a3242187f6a5a68b060f
author Lorenzo Drumond <drumondlorenzo@posteo.net> 1721841147 +0100
committer Lorenzo Drumond <drumondlorenzo@posteo.net> 1721841147 +0100

A: add contents.md
```

We can see:

- The tree object
- The author
- The committer
- The commit message

However, we cannot see the contents of the contents.md file itself! That's because the tree object stores it.

## Optimisation

Git stores an entire snapshot of files on a per-commit level.

While it's true that Git stores entire snapshots, it does have some performance optimizations so that your .git directory doesn't get too unbearably large.

- Git compresses and packs files to store them more efficiently.
- Git deduplicates files that are the same across different commits. If a file doesn't change between commits, Git will only store it once.

<!--notes: 742ae47550048eceeb91822826d4e6bca55fb897-->

## Configuration

git has one global configuration, and one local (per repo) configuration. They way to set or retrieve config values is via

```bash
git config
```

you can store any value in the config, but only some will be used by git

```bash
git config --add --global webflyx.ceo "ThePrimeagen"
git config --add --global webflyx.cto "TheLaneagen"
git config --add --global webflyx.evaluation "mid"

# to view the config
git config --list --local

# to get a key
git config --get <key>

# remove a value
git config --unset <key>

# remove a section
git config --remove-section <section>
```

git configuration allows for duplicate keys. To operate on all duplicate keys, you can use the variants `get-all` and `unset-all`

### Locations

There are several locations where Git can be configured. From more general to more specific, they are:

- system: /etc/gitconfig, a file that configures Git for all users on the system
- global: ~/.gitconfig, a file that configures Git for all projects of a user
- local: .git/config, a file that configures Git for a specific project
- worktree: .git/config.worktree, a file that configures Git for part of a project

If you set a configuration in a more specific location, it will override the same configuration in a more general location.

## Branches

A Git branch allows you to keep track of different changes separately.

When you make a commit, Git stores a commit object that contains a pointer to the snapshot of the
content you staged. This object also contains the author’s name and email address, the message that
you typed, and pointers to the commit or commits that directly came before this commit (its parent
or parents): zero parents for the initial commit, one parent for a normal commit, and multiple
parents for a commit that results from a merge of two or more branches.

A branch is just a named pointer to a specific commit. When you create a branch, you are creating a new pointer to a specific commit. The commit that the branch points to is called the tip of the branch.

Because a branch is just a pointer to a commit, they're lightweight and "cheap" resource-wise to create. When you create 10 branches, you're not creating 10 copies of your project on your hard drive.

```bash
# rename a branch
git branch -m oldname newname

# new branch
git branch new_branch

# create and switch
git switch -c new_branch

# switch from a specific commit
git switch -c new_branch <HASH>
```

The switch command allows you to switch branches, and the -c flag tells Git to create a new branch if it doesn't already exist.

When you create a new branch, it uses the current commit you are on as the branch base.

Git stores all its information in files in the .git subdirectory at the root of your project, even information about branches. The "heads" (or "tips") of branches are stored in the .git/refs/heads directory. If you cat one of the files in that directory, you should be able to see the commit hash that the branch points to.

refs are pointers to commits. All branches are refs, but not all refs are branches.

## Merging

Once you're happy with your changes, you'll want to merge them back into the main branch so that they make their way into the final product.

A - B - C    main
   \
    D - E    other_branch

If you merge other_branch into main, Git combines both branches by creating a new commit that has both histories as parents. In the diagram below, F is a merge commit that has C and E as parents. F brings all the changes from D and E back into the main branch.

A - B - C - F    main
   \     /
    D - E        other_branch

```bash
# nice ascii art
git log --oneline --graph --all
```

How does merging happen?

Let's say we start with this:

A - B - C    main
   \
    D - E    vimchadsonly

And we merge vimchadsonly into main by running this while on main:

```bash
git merge vimchadsonly
```

The merge will:

- Find the "merge base" commit, or "best common ancestor" of the two branches. In this case, "A".
- Replays the changes from vimchadsonly onto main starting from the best common ancestor (so, starting from "A", apply all changes of main into a new commit "F", and then all changes from vimchadsonly on "F" as if were "A")
- Records the result as a new commit, in our case "F".
- "F" is special because it has two parents, "C" and "E".

After:

A - B - C - F    main
   \     /
    D - E        vimchadsonly


## Merge types

The simplest type of merge is a fast-forward merge. Let's say we start with this:

      C     delete_vscode
     /
A - B       main

and while on main, we run

```bash
git merge delete_vscode
```

Because delete_vscode has all the commits that main has, Git automatically does a fast-forward merge. It just moves the pointer of the "base" branch to the tip of the "feature" branch:

            other_branch
A - B - C   main

With a fast-forward merge, no merge commit is created.


1. Create a branch for a new change
2. Make the change
3. Merge the branch back into main (or whatever branch your team dubs the "default" branch)
4. Remove the branch
5. Repeat

to delete

```bash
git branch -D add_classics
```

## Rebase

Say we have this commit history:

A - B - C    main
   \
    D - E    feature_branch

We're working on feature_branch, and want to bring in the changes our team added to main so we're not working with a stale branch. We could merge main into feature_branch, but that would create an additional merge commit. Rebase avoids a merge commit by replaying the commits from feature_branch on top of main. After a rebase, the history will look like this:

A - B - C         main
         \
          D - E   feature_branch

You generally want to rebase the _feature_ branch to the tip of the base branch, NOT THE OTHER WAY AROUND!. This allows you to merge feature into base with a fast-forward merge, which doesn't clutter commit history with merge commits.

# References

- boot.dev
- progit

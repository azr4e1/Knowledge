---
title: Linear Time Majority Algorithm
author: Lorenzo Drumond
date: 2024-03-12T22:55:56
last: 2024-03-12T23:03:46
zk_id: fc26fc84d14a61374dbdb94ec3275382
tags: #sequence #algorithm #programming #array #coding #golang #majority #linear #computer_science
---


# Linear Time Majority Algorithm
Given an array of length n, calculate the majority element, which is the element which appears the most, with time complexity O(n) and space complexity of O(1)

We will sweep down the sequence starting at the pointer position shown above.

As we sweep we maintain a pair consisting of a current candidate and a counter. Initially, the current candidate is unknown and the counter is 0.

When we move the pointer forward over an element e:

1. If the counter is 0, we set the current candidate to e and we set the counter to 1.
2. If the counter is not 0, we increment or decrement the counter according to whether e is the current candidate.

When we are done, the current candidate is the majority element, if there is a majority.

```go
type Vote struct {
  Candidate int
  Vote      int
}

func calculateMajority(nums []int) int {
  vote := new(Vote)
  for _, v := range nums {
    if vote.Votes == 0 {
      vote.Candidate = n
      vote.Vote = 1
      continue
    }
    if nums == vote.Candidate {
      vote.Vote++
    } else {
      vote.Vote--
    }
  }

  return vote.Candidate
}
```

# References
- https://www.cs.utexas.edu/~moore/best-ideas/mjrty/example.html
